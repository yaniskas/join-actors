# JoinActors: Fair Join Pattern Matching for Actors

## Description

This library implements join patterns in Scala 3, a coordination mechanism for
concurrent message-passing programs, first introduced in the join calculus. Join
patterns allow to declaratively specify how to react and synchronize distributed
computations.

The library offers a convenient and safe method to define and utilize join
patterns in Scala 3. It achieves this by leveraging Scala 3's metaprogramming
capabilities, extending the language through the use of macros and the
reflection API. We use the Scala 3 pattern matching syntax to define join
patterns, and the library converts these into an internal representation using
the aforementioned techniques.

Additionally, the library uses the Actor model as a practical example to
demonstrate the application of join patterns. At present, we are employing a
simple homemade actor model implementation.

## Code base structure

The source code for the join patterns library is organized as follows:

- `join-actors/core`: Contains the core implementation of the join patterns library.

  - `join-actors/core/src/main/scala/`: Has the following subpackages:

    - `actor`: Contains the prototype actor implementation.
    
    - `api`: Re-exports the API of the library for easy importing in user code with `import join_actors.api.*` 

    - `join_patterns`: Contains the implementation of the join pattern
      matching algorithm and code generation macros.
      - `matching`: Contains all implemented join pattern matching algorithms 
        - `Matcher.scala`: The matcher trait that is implemented by the
          different join pattern matching algorithms.
        - `MatchingAlgorithm.scala`: An enumeration used for selecting an algorithm
        - `brute_force`: The brute-force matcher implementation.
        - `immutable`: The stateful tree-based matcher
          implementation.
        - `mutable`: The mutable, single-traversal matcher implementation
        - `lazy_mutable`: The implementation implementing the lazy matching algorithm
        - `while_lazy`: The implementation with lazy matching and optimized loops
        - `while_eager`: The implementation with optimized loops, but not lazy matching
        - `eager_parallel`: The non-lazy parallel matching algorithm
        - `lazy_parallel`: The lazy parallel matching algorithm
        - `filtering_while`: The singlethreaded filtering algorithm
        - `filtering_parallel`: The multithreaded filtering algorithm
        - `array_while`: The array-based matching algorithm
        - `functions`: Utility functions for matching which are used by all algorithms
      - `util`: Miscellaneous utilities used by the other code
      - `CodeGenerationMacros.scala`: Defines the `receive` macro used to create join definitions
      - `JoinPattern.scala`: Infrastructure code used by the macros and join pattern matching matching algorithms 

    - `examples`: Contains examples demonstrating the use of the library.

- `join-actors/benchmarks`: Contains the benchmarking code for the join patterns library.

  - `join-actors/benchmarks/src/main/scala/`: Has the following subpackages:

    - `old_benchmarks`: The old benchmark implementation
    - `new_benchmarks`: The new benchmark implementation
      - `Benchmark.scala`: The trait implemented by all runnable benchmarks
      - `BenchmarkFactory.scala`: The trait implemented by all "benchmark archetype" factories
      - `Running.scala`: The code used for running benchmarks
      - `Processing.scala`: The code used for processing benchmark data before writing it
      - `Writing.scala`: The code used for writing benchmark data to csv files and plots
      - `Utils.scala`: Utility functions used by the benchmark suite
      - `mixin/MessageFeedBenchmark.scala`: A superclass containing code common to some benchmark implementations
      - `simple_smart_house`, `complex_smart_house`, `bounded_buffer`, `size`, `size_with_guards`: Benchmark implementations
  - `join-actors/benchmarks/data`: The default directory for data files generated by the benchmarks.
    - Every benchmark creates a file of the form `{{yyyy_MM_dd_HH_mm_ss}}_{{benchmark_description}}.csv/`. This file contains:
      - A column containing parameter values
      - For each algorithm used in the benchmark:
        - Columns for the data from every repetition
        - A column containing the average of the repetition results
        - A column containing the standard deviation of the repetition results
    - Unless the `--suppressPlot` flag is given, a plot of the results will also be created. The points of the plot are made from
      the average results, and the error bars show standard deviations

## API usage

The library provides a simple API to define join patterns. The following example
demonstrates how to define a join pattern for a simple factory shop floor
monitoring system, as seen in the paper:

- First add the necessary imports:

```scala
import join_actors.api.*
```

- Define the messages that the actors will exchange. We use Scala 3 enums to
  define the message types with their respective payloads:

```scala
enum MachineEvent:
  case Fault(faultID: Int, ts: Long)

enum WorkerEvent:
  case Fix(faultID: Int, ts: Long)

enum SystemEvent:
  case DelayedFault(faultID: Int, ts: Long)
  case Shutdown()

type Event = MachineEvent | WorkerEvent | SystemEvent
```

- Now we define the monitor as an actor with join definitions using the `receive` macro.
  Join patterns are written as message patterns separated by the `&:&` operator, and followed by a guard condition. 
  The old tuple-like syntax is also supported

```scala
def monitor(algorithm: MatchingAlgorithm) =
  Actor[Event, Unit] {
    receive { (self: ActorRef[Event]) =>
      {
        case Fault(fid1, ts1) &:& Fix(fid2, ts2) if fid1 == fid2 => ...
        case Fault(fid1, ts1) &:& Fault(fid2, ts2) &:& Fix(fid3, ts3)
            if fid2 == fid3 && ts2 > ts1 + TEN_MIN => ...
        case DelayedFault(fid1, ts1) &:& Fix(fid2, ts2) if fid1 == fid2 => ...
        ...
      }
    }(algorithm)
  }
```

- Finally, we can run the monitor as follows:

```scala
def runFactorySimple(algorithm: MatchingAlgorithm) =
  // Predefined sequence of events
  val events = List(
    Fault(1, ONE_MIN),
    Fault(2, TEN_MIN),
    Fault(3, QUARTER_HR),
    Fix(3, THIRTY_MIN)
  )

  // Start the monitor actor
  val (monitorFut, monitorRef) = monitor(algorithm).start()

  // Send the events to the monitor actor
  events foreach (event => monitorRef ! event)

  // Shutdown the monitor actor
  monitorRef ! Shutdown()

  // Wait for the monitor actor to finish
  Await.ready(monitorFut, Duration(15, "m"))
```

The algorithm can be set to any of the cases defined in the `MatchingAlgorithm` enumeration, allowing access to all implemented algorithms.
In the example above, some minor details are omitted for brevity. The full
example can be found in the [FactorySimpl.scala](core/src/main/scala/examples/FactorySimpl.scala) file.


## Build and test

The library can be compiled by installing a [Java Development Kit (version 21 or later)](https://jdk.java.net/21/) and
[sbt (version 1.9 or later)](https://www.scala-sbt.org/) and running `sbt compile`. Then, `sbt` will download the required
dependencies (including the Scala 3 compiler).

To compile the library, run the following command from the root directory (where
the `build.sbt` file is located):

```bash
sbt clean compile
```

To run the tests of the core library, run the following command:

```bash
sbt core/test
```

To run for instance the `Factory Simple` example with the predefined configuration
run the following command:

```bash
sbt "core/run factory-simple --algorithm stateful"
```

The `--algorithm` flag can be set to any of the following, allowing access to all implemented algorithms:

- `brute`
- `stateful`
- `mutable`
- `lazy-mutable`
- `while-lazy`
- `while-eager`
- `eager-parallel`
- `lazy-parallel`
- `filtering-while`
- `filtering-parallel`
- `array-while`

There are other examples available in the `examples` package that can be run in a similar way.

## Benchmarks

See the [benchmarks README](benchmarks/README.md) for more information on how to
run the benchmarks.
